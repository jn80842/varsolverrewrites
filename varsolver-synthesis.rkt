#lang rosette

(require "halide-lang.rkt")
(require "halide-sketch.rkt")
(require "halide-print-sketch.rkt")
(require "halide-parser.rkt")

;; assume LHS is a function that takes the same inputs as the RHS sketch
(define (synthesize-rewrite LHS sk inputs)
  (let* ([evaled-sketch (apply (get-sketch-function sk) inputs)]
         [evaled-LHS (apply LHS inputs)]
         [model (time (synthesize #:forall (symbolics inputs)
                                  #:guarantee (assert (equal? evaled-sketch evaled-LHS))))])
    (if (unsat? model)
        (displayln "Could not find an equivalent RHS")
        (displayln (print-sketch (evaluate sk model))))))

(define LHS1
  (λ (i1 i2 i3)
    (hld-add (hld-mul i1 i2) (hld-mul i1 i3))))

(define sk1 (get-symbolic-sketch operator-list 3 3))

(define-symbolic* i1 integer?)
(define-symbolic* i2 integer?)
(define-symbolic* i3 integer?)

(define inputs (list i1 i2 i3))

;(synthesize-rewrite LHS1 sk1 (list i1 i2 i3))

;; (rewrite(max(t0 + n0, t0 + n1), (t0 + max(n0, n1)), "coqMax396c"))

(define LHS2
  (λ (t0 n0 n1) (max (+ t0 n0) (+ t0 n1))))

(define-symbolic* sym-op-idx integer?)

(define sk2 (get-symbolic-sketch operator-list 2 2))

(define-symbolic* sym-tarvar integer?)

(define (synthesize-topn-rewrite LHS sk op-idx tarvar inputs)
  (let* ([evaled-sketch (apply (get-topn-sketch-function sk op-idx) tarvar inputs)]
         [evaled-LHS (apply LHS tarvar inputs)]
         [model (time (synthesize #:forall (symbolics (cons tarvar inputs))
                                  #:guarantee (assert (equal? evaled-sketch evaled-LHS))))])
    (if (unsat? model)
        (displayln "Could not find equivalent RHS")
        (displayln (print-topn-sketch (evaluate sk model) (evaluate op-idx model))))))

(define (pull-out-target-var var-list target-idx)
  (let ([size (length var-list)])
    (append (list (list-ref var-list target-idx)) (take var-list target-idx) (drop var-list (add1 target-idx)))))

(define (insert-target-var nv-list tarvar target-idx)
  (append (take nv-list target-idx) (list tarvar) (drop nv-list target-idx)))

;; assumptions:
;; LHS contains 3 variables
(define (synthesize-3var-rewrite LHS-string LHS-func tar-idx)
  (let* ([op-count (halide->countops LHS-string)]
         [sk (get-symbolic-sketch operator-list 2 op-count)]
         [renamed-LHS (halide->renamevars LHS-string (make-hash (map cons (list "x" "y" "z")
                                                                     (insert-target-var (list "n0" "n1") "t0" tar-idx))))])
    (begin
      (clear-asserts!)
      (define-symbolic* tarvar integer?)
      (define-symbolic* n0 integer?)
      (define-symbolic* n1 integer?)
      (define-symbolic* root-op integer?)
      (let* ([evaled-sketch (apply (get-topn-sketch-function sk root-op) tarvar (list n0 n1))]
             [evaled-LHS (apply LHS-func (insert-target-var (list n0 n1) tarvar tar-idx))]
             [model (time (with-handlers ([(λ (e) #t)
                                           (λ (e) (displayln (format "Timeout in search for RHS for ~a" renamed-LHS)))])
                            (synthesize #:forall (list tarvar n0 n1)
                                        #:guarantee (assert (equal? evaled-sketch evaled-LHS)))))])
        (if (or (unsat? model) (void? model))
            (displayln (format "Could not find equivalent RHS for ~a" renamed-LHS))
            (displayln (format "rewrite(~a, ~a);" renamed-LHS
                               (topn-sketch->halide-expr (evaluate sk model) (evaluate root-op model))))))
            )))


(define patts (list
(cons "((x/y)*z)" (λ (x y z) (hld-mul (hld-div x y) z)))
(cons "((x/y)/z)" (λ (x y z) (hld-div (hld-div x y) z)))
(cons "(x/(y/z))" (λ (x y z) (hld-div x (hld-div y z))))
(cons "((x*y)*z)" (λ (x y z) (hld-mul (hld-mul x y) z)))
(cons "((x/y)*z)" (λ (x y z) (hld-mul (hld-div x y) z)))
(cons "(x + (y*z))" (λ (x y z) (hld-add x (hld-mul y z))))
(cons "((x/y) + z)" (λ (x y z) (hld-add (hld-div x y) z)))
(cons "((x - y)/z)" (λ (x y z) (hld-div (hld-sub x y) z)))
(cons "min(x*y, z)" (λ (x y z) (min (hld-mul x y) z)))
(cons "((x*y) + z)" (λ (x y z) (hld-add (hld-mul x y) z)))
(cons "((x + y)/z)" (λ (x y z) (hld-div (hld-add x y) z)))
(cons "((x % y)*z)" (λ (x y z) (hld-mul (hld-mod x y) z)))
(cons "((x/y) < z)" (λ (x y z) (hld-lt (hld-div x y) z)))
(cons "(x*(y + z))" (λ (x y z) (hld-mul x (hld-add y z))))
(cons "((x + y)*z)" (λ (x y z) (hld-mul (hld-add x y) z)))
(cons "((x - y)*z)" (λ (x y z) (hld-mul (hld-sub x y) z)))
(cons "(x - (y/z))" (λ (x y z) (hld-sub x (hld-div y z))))
(cons "((x*y) - z)" (λ (x y z) (hld-sub (hld-mul x y) z)))
(cons "(x + (y/z))" (λ (x y z) (hld-add x (hld-div y z))))
(cons "(x - (y*z))" (λ (x y z) (hld-sub x (hld-mul y z))))
(cons "((x*y) + z)" (λ (x y z) (hld-add (hld-mul x y) z)))
(cons "((x/y) - z)" (λ (x y z) (hld-sub (hld-div x y) z)))
(cons "(x + (y*z))" (λ (x y z) (hld-add x (hld-mul y z))))
(cons "((x/y) + z)" (λ (x y z) (hld-add (hld-div x y) z)))
(cons "min(x, y/z)" (λ (x y z) (min x (hld-div y z))))
(cons "max(x*y, z)" (λ (x y z) (max (hld-mul x y) z)))
(cons "min(x/y, z)" (λ (x y z) (min (hld-div x y) z)))
(cons "max(x, y/z)" (λ (x y z) (max x (hld-div y z))))
(cons "max(x/y, z)" (λ (x y z) (max (hld-div x y) z)))
(cons "(x < (y/z))" (λ (x y z) (hld-lt x (hld-div y z))))
(cons "min(x, y*z)" (λ (x y z) (min x (hld-mul y z))))
(cons "(x < (y*z))" (λ (x y z) (hld-lt x (hld-mul y z))))
(cons "((x + y)/z)" (λ (x y z) (hld-div (hld-add x y) z)))
(cons "max(x, y*z)" (λ (x y z) (max x (hld-mul y z))))
(cons "(x/(y + z))" (λ (x y z) (hld-div x (hld-add y z))))
(cons "((x/y) % z)" (λ (x y z) (hld-mod (hld-div x y) z)))
(cons "(x % (y/z))" (λ (x y z) (hld-mod x (hld-div y z))))
(cons "((x + y)*z)" (λ (x y z) (hld-mul (hld-add x y) z)))
(cons "((x*y) < z)" (λ (x y z) (hld-lt (hld-mul x y) z)))
(cons "(x*(y - z))" (λ (x y z) (hld-mul x (hld-sub y z))))
(cons "(x <= (y/z))" (λ (x y z) (hld-le x (hld-div y z))))
(cons "(x <= (y*z))" (λ (x y z) (hld-le x (hld-mul y z))))
(cons "(x <= (y/z))" (λ (x y z) (hld-le x (hld-div y z))))
(cons "(x <= (y*z))" (λ (x y z) (hld-le x (hld-mul y z))))
(cons "!((x/y) < z)" (λ (x y z) (hld-not (hld-lt (hld-div x y) z))))
(cons "((x/y) <= z)" (λ (x y z) (hld-le (hld-div x y) z)))
(cons "((x/y) >= z)" (λ (x y z) (hld-ge (hld-div x y) z)))
(cons "((x*y) >= z)" (λ (x y z) (hld-ge (hld-mul x y) z)))
(cons "((x*y) <= z)" (λ (x y z) (hld-le (hld-mul x y) z)))
(cons "(x >= (y*z))" (λ (x y z) (hld-ge x (hld-mul y z))))
(cons "!(x < (y/z))" (λ (x y z) (hld-not (hld-lt x (hld-div y z)))))
(cons "((x + y) + z)" (λ (x y z) (hld-add (hld-add x y) z)))
(cons "(x - (y % z))" (λ (x y z) (hld-sub x (hld-mod y z))))
(cons "((x + y) % z)" (λ (x y z) (hld-mod (hld-add x y) z)))
(cons "min(x, y + z)" (λ (x y z) (min x (hld-add y z))))
(cons "(x + (y + z))" (λ (x y z) (hld-add x (hld-add y z))))
(cons "((x + y) < z)" (λ (x y z) (hld-lt (hld-add x y) z)))
(cons "max(x + y, z)" (λ (x y z) (max (hld-add x y) z)))
(cons "((x + y) - z)" (λ (x y z) (hld-sub (hld-add x y) z)))
(cons "(x < (y % z))" (λ (x y z) (hld-lt x (hld-mod y z))))
(cons "(x + (y - z))" (λ (x y z) (hld-add x (hld-sub y z))))
(cons "((x + y) < z)" (λ (x y z) (hld-lt (hld-add x y) z)))
(cons "!(x <= (y/z))" (λ (x y z) (hld-not (hld-le x (hld-div y z)))))
(cons "(x < (y + z))" (λ (x y z) (hld-lt x (hld-add y z))))
(cons "((x % y) < z)" (λ (x y z) (hld-lt (hld-mod x y) z)))
(cons "((x - y) + z)" (λ (x y z) (hld-add (hld-sub x y) z)))
(cons "(x - (y - z))" (λ (x y z) (hld-sub x (hld-sub y z))))
(cons "max(x, y + z)" (λ (x y z) (max x (hld-add y z))))
(cons "min(x, y - z)" (λ (x y z) (min x (hld-sub y z))))
(cons "max(x - y, z)" (λ (x y z) (max (hld-sub x y) z)))
(cons "min(x - y, z)" (λ (x y z) (min (hld-sub x y) z)))
(cons "min(x + y, z)" (λ (x y z) (min (hld-add x y) z)))
(cons "((x - y) - z)" (λ (x y z) (hld-sub (hld-sub x y) z)))
(cons "(x - (y + z))" (λ (x y z) (hld-sub x (hld-add y z))))
(cons "(x + (y + z))" (λ (x y z) (hld-add x (hld-add y z))))
(cons "(max(x, y)*z)" (λ (x y z) (hld-mul (max x y) z)))
(cons "(min(x, y)*z)" (λ (x y z) (hld-mul (min x y) z)))
(cons "(min(x, y)/z)" (λ (x y z) (hld-div (min x y) z)))
(cons "((x + y) + z)" (λ (x y z) (hld-add (hld-add x y) z)))
(cons "(((x/y)/z)*z)" (λ (x y z) (hld-mul (hld-div (hld-div x y) z) z)))
(cons "min((x*y), z)" (λ (x y z) (min (hld-mul x y) z)))
(cons "min(x/y, z/y)" (λ (x y z) (min (hld-div x y) (hld-div z y))))
(cons "min(x*y, z*y)" (λ (x y z) (min (hld-mul x y) (hld-mul z y))))
(cons "((x % y) + z)" (λ (x y z) (hld-add (hld-mod x y) z)))
(cons "(x % (y + z))" (λ (x y z) (hld-mod x (hld-add y z))))
(cons "(max(x, y)/z)" (λ (x y z) (hld-div (max x y) z)))
(cons "min((x), y/z)" (λ (x y z) (min x (hld-div y z))))
(cons "max(x*y, z*y)" (λ (x y z) (max (hld-mul x y) (hld-mul z y))))
(cons "(((x/y)/y)*z)" (λ (x y z) (hld-mul (hld-div (hld-div x y) y) z)))
(cons "max(x, y - z)" (λ (x y z) (max x (hld-sub y z))))
(cons "((x % y) - z)" (λ (x y z) (hld-sub (hld-mod x y) z)))
(cons "((x + y) + z)" (λ (x y z) (hld-add (hld-add x y) z)))
(cons "max(x/y, z/y)" (λ (x y z) (max (hld-div x y) (hld-div z y))))
(cons "((x + y) <= z)" (λ (x y z) (hld-le (hld-add x y) z)))
(cons "(x <= (y + z))" (λ (x y z) (hld-le x (hld-add y z))))
(cons "((x - y) <= z)" (λ (x y z) (hld-le (hld-sub x y) z)))
(cons "((x + y) <= z)" (λ (x y z) (hld-le (hld-add x y) z)))
(cons "(x || (y < z))" (λ (x y z) (hld-or x (hld-lt y z))))
(cons "!(x < (y + z))" (λ (x y z) (hld-not (hld-lt x (hld-add y z)))))
(cons "!((x + y) < z)" (λ (x y z) (hld-not (hld-lt (hld-add x y) z))))
))

(for ([lhs (list (list-ref patts 20))])
  (begin
    (synthesize-3var-rewrite (car lhs) (cdr lhs) 0)
    (synthesize-3var-rewrite (car lhs) (cdr lhs) 1)
    (synthesize-3var-rewrite (car lhs) (cdr lhs) 2)))
